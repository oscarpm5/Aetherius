// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Worley3DTextureWithPoints
#pragma kernel Perlin3DTexture

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture3D<float4> Result3D;
StructuredBuffer<float3> pointsA;
StructuredBuffer<float3> pointsB;
StructuredBuffer<float3> pointsC;

int textureSizeP;//Texture Size in pixels
int numCellsA;
int numCellsB;
int numCellsC;

float GetRandomIndexFromPoint(float3 p,int numOfCellsAxis)
{  
    return p.x + numOfCellsAxis * (p.y + numOfCellsAxis * p.z);
}

float GetWorleyDistFromCellNumWithPoints(uint3 id, float cellsNum, StructuredBuffer<float3> randomPoints)
{
    float3 st = id.xyz/float(textureSizeP); //convert pixel space into 0 to 1 coordinates
    st*=float(cellsNum);
   
    float3 iPos = floor(st); //get integer coords
    float3 fPos = frac(st); //get fractional coords


    float minDist=  1.0;  // minimum distance
    for(int z=-1; z<=1;++z)
    {
        for(int y=-1; y<=1;++y)
        {
            for(int x=-1; x<=1;++x)
            {
                float3 neighbourOffset= float3(float(x),float(y),float(z)); //get an offset for the 26 adjacent tiles + the center one
                float3 neighbourPos =iPos+neighbourOffset; //Position of the cell where we want to obtain the random point
            
                if(neighbourPos.x<0.0f) //Cannot do modulo if its a negative number
                {
                    neighbourPos.x=cellsNum-1.0;
                }

                if(neighbourPos.y<0.0f)//Cannot do modulo if its a negative number
                {
                    neighbourPos.y=cellsNum-1.0;
                }
                if(neighbourPos.z<0.0f)//Cannot do modulo if its a negative number
                {
                    neighbourPos.z=cellsNum-1.0;
                }

                neighbourPos= neighbourPos % cellsNum;
                float3 randPoint=randomPoints[GetRandomIndexFromPoint(neighbourPos,cellsNum)]; //take a random point given the position of the current tile + the offset of the neighbour we are checking as a seed
                float3 distV = neighbourOffset+randPoint - fPos; //we calculate the distance vector between the position in our tile and the position of the random point in the neighbouring tile
                float dist = length(distV); //we calculate the distance from the distance vector
                minDist= min(minDist,dist); //we take the minimum distance from all neighbours
            }
        }
    }

    return minDist;
}

[numthreads(8,8,8)]
void Worley3DTextureWithPoints (uint3 id : SV_DispatchThreadID)
{
    float layeredVal=0.0;
    layeredVal += GetWorleyDistFromCellNumWithPoints(id,float(numCellsA),pointsA)*0.625;
    layeredVal += GetWorleyDistFromCellNumWithPoints(id,float(numCellsB),pointsB)*0.25;
    layeredVal += GetWorleyDistFromCellNumWithPoints(id,float(numCellsC),pointsC)*0.125;
    layeredVal= 1-layeredVal;//we invert the distance
    
    Result3D[id.xyz] = float4(layeredVal,layeredVal,layeredVal,1.0);

}

StructuredBuffer<float3> vecTable;

StructuredBuffer<int> permTableA;
StructuredBuffer<int> permTableB;
StructuredBuffer<int> permTableC;
int permTableSizeA;
int permTableSizeB;
int permTableSizeC;

int WrapPosComponent(int posComp,int wrapNum)
{
    if(posComp<0)
    {
        return (wrapNum-1);  
    }
    return (posComp % wrapNum);
}

int GetpermutationIndexFromPos(int3 pos,int permTableSize, StructuredBuffer<int>permTable)
{
    int index = permTable[WrapPosComponent(int(pos.x),permTableSize)];
    index= permTable[WrapPosComponent(int(index+pos.y),permTableSize)];
    index= permTable[WrapPosComponent(int(index+pos.z),permTableSize)];

    return index;
}

float3 GetGradientVectorFromPos(int3 pos,int permTableSize,StructuredBuffer<int>permTable)
{
    int vecIndex=GetpermutationIndexFromPos(pos,permTableSize,permTable)&7;
    return vecTable[vecIndex];
}

float Fade(float t){
	return ((6.0*t - 15.0)*t + 10.0)*t*t*t;
}

float3 GetPerlinGradient(uint3 id, int permTableSize,StructuredBuffer<int>permTable)
{
    float3 st = id.xyz/float(textureSizeP); //convert pixel space into 0 to 1 coordinates
    st*=float(permTableSize); //TODO this might be permTableSize-1?
   
    float3 iPos = floor(st); //get integer coords
    float3 fPos = frac(st); //get fractional coords

    float3 vecBLC = GetGradientVectorFromPos(int3(iPos.x,iPos.y,iPos.z)+int3(0,0,0),permTableSize,permTable);//bottom left close corner
    float3 vecBLF = GetGradientVectorFromPos(int3(iPos.x,iPos.y,iPos.z)+int3(0,0,1),permTableSize,permTable);//bottom left far corner
    float3 vecBRC = GetGradientVectorFromPos(int3(iPos.x,iPos.y,iPos.z)+int3(1,0,0),permTableSize,permTable);//bottom right close corner
    float3 vecBRF = GetGradientVectorFromPos(int3(iPos.x,iPos.y,iPos.z)+int3(1,0,1),permTableSize,permTable);//bottom right far corner
    float3 vecTLC = GetGradientVectorFromPos(int3(iPos.x,iPos.y,iPos.z)+int3(0,1,0),permTableSize,permTable);//top left close corner
    float3 vecTLF = GetGradientVectorFromPos(int3(iPos.x,iPos.y,iPos.z)+int3(0,1,1),permTableSize,permTable);//top left far corner
    float3 vecTRC = GetGradientVectorFromPos(int3(iPos.x,iPos.y,iPos.z)+int3(1,1,0),permTableSize,permTable);//top right close corner
    float3 vecTRF = GetGradientVectorFromPos(int3(iPos.x,iPos.y,iPos.z)+int3(1,1,1),permTableSize,permTable);//top right far corner

    float dotVecBLC = dot(vecBLC,fPos-float3(0.0,0.0,0.0));
    float dotVecBLF = dot(vecBLF,fPos-float3(0.0,0.0,1.0));
    float dotVecBRC = dot(vecBRC,fPos-float3(1.0,0.0,0.0));
    float dotVecBRF = dot(vecBRF,fPos-float3(1.0,0.0,1.0));
    float dotVecTLC = dot(vecTLC,fPos-float3(0.0,1.0,0.0));
    float dotVecTLF = dot(vecTLF,fPos-float3(0.0,1.0,1.0));
    float dotVecTRC = dot(vecTRC,fPos-float3(1.0,1.0,0.0));
    float dotVecTRF = dot(vecTRF,fPos-float3(1.0,1.0,1.0));
    
    float u = Fade(fPos.x); //we use this instead of a linear value to not have hard edges, we also use this instead of smoothstep as it has no discontinuities
    float v = Fade(fPos.y);
    float w = Fade(fPos.z);

    float dotVecBL = lerp(dotVecBLC,dotVecBLF,w);
    float dotVecBR = lerp(dotVecBRC,dotVecBRF,w);
    float dotVecTL = lerp(dotVecTLC,dotVecTLF,w);
    float dotVecTR = lerp(dotVecTRC,dotVecTRF,w);

    float dotVecB = lerp(dotVecBL,dotVecBR,u);
    float dotVecT = lerp(dotVecTL,dotVecTR,u);

    float finalPoint=(0.5*lerp(dotVecB,dotVecT,v))+0.5;

    return float3(finalPoint,finalPoint,finalPoint);
}


[numthreads(8,8,8)]
void Perlin3DTexture(uint3 id : SV_DispatchThreadID)
{

    float3 layeredVal = GetPerlinGradient(id, permTableSizeA,permTableA);

    Result3D[id.xyz] = float4(layeredVal.x,layeredVal.y,layeredVal.z,1.0);

}